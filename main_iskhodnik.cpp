//--------подключение библиотек--------------------------------------
//-------------------------------------------------------------------
#define F_CPU       			//частота процессора
                                //описание памяти МК
#include <avr/interrupt.h>      //прерывания
#include <util/delay.h>         //задержки времени
//*******************************************************************

//--------определение выводов дисплея МТ16S2H------------------------
//-------------------------------------------------------------------
#define A0_PORT PORTB //команда/данные
#define A0_DDR  DDRB
#define A0      5 

#define E_PORT PORTB  //управление синхронизацией
#define E_DDR  DDRB
#define E      4 

//шина данных дисплея
#define DB4_PORT PORTB
#define DB4_DDRD DDRB   
#define DB4      0

#define DB5_PORT PORTB
#define DB5_DDRD DDRB
#define DB5      1

#define DB6_PORT PORTB
#define DB6_DDRD DDRB
#define DB6      2

#define DB7_PORT PORTB
#define DB7_DDRD DDRB
#define DB7      3

#define set_A0() A0_PORT|=1<<A0     //управление линией команда/данные
#define clr_A0() A0_PORT&=~(1<<A0)

#define set_E()  E_PORT|=1<<E       //управление линией синхронизации
#define clr_E()  E_PORT&=~(1<<E)
//*******************************************************************

//--------функции для работы с ЖКИ МТ16S2H---------------------------
//-------------------------------------------------------------------
#define MT16S2H_on()       MT16S2H_write(0x0C,COMMAND)  //включение дисплея
#define MT16S2H_getchar(c) MT16S2H_write(c,DATA)        //вывод символа

void MT16S2H_init(void);                                //инициализация дисплея
void MT16S2H_clr(void);                                 //очистка дисплея
void MT16S2H_gotoxy(unsigned char x,unsigned char y);   //перевод курсора (х от 0 до 15, y 0 или 1)
void MT16S2H_putstr(char *str);                         //вывод текстовой строки

void MT16S2H_set_DB(unsigned char data);                //установка шины данных

#define DATA    1
#define COMMAND 0
void MT16S2H_write(unsigned char data,unsigned char a); //передача данных
//*******************************************************************

//--------Формирование мелодии будильника----------------------------
//-------------------------------------------------------------------
//--------НОТЫ-------------------------------------------------------
enum Notes {C1=0,C1d,D1,D1d,E1,F1,F1d,G1,G1d,A1,A1d,H1,C2};         //обозначения нот
unsigned char rateNotes[]={78,73,69,65,61,58,55,51,49,46,43,41,38}; //значения для OCR0A

//--------мелодия будильника-----------------------------------------
#define melodyLenght 40					//количество нот в мелодии
unsigned char melody[2][melodyLenght]=  //в нулевом массиве номер ноты, в первом массиве длительность ноты
{{F1,E1,D1,C1,G1,G1, F1,E1,D1,C1,G1,G1, F1,A1,A1,F1, E1,G1,G1,E1, D1,E1,F1,D1,C1,C1, F1,A1,A1,F1, E1,G1,G1,E1, D1,E1,F1,D1,C1,C1},
 { 4, 4, 4, 4, 2, 2,  4, 4, 4, 4, 2, 2,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 2, 2,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, 2, 2}};

#define soundON() TIMSK2=1<<OCIE2A		//запуск одного полного воспроизведения мелодии
//*******************************************************************

//--------обработка ввода--------------------------------------------
//-------------------------------------------------------------------
typedef enum {       //возможные состояния энкодера
    notR,            //нет вращения  
    left,            //поворот  против часовой стрелки
    right            //поворот по часовой стрелки
} Dir;
Dir direction=notR;  //направление вращения энкодера
Dir encoderStatus(void){Dir temp=direction;direction=notR;return temp;}//функция возвращает состояние энкодера и сбрасывает статус для исключения повторного срабатывания

typedef enum{   //состояние кнопки
    noPress,    //не нажато
    shortPress, //корокое нажатие
    longPress   //длинное нажатие
} Button;
#define shortTime 150  //время короткого нажатия кнопки
#define longTime  500  //время длинного нажатия кнопки

Button getKey(unsigned char tick);  //опрос кнопки, необходимо передавать интервал времен между вызовами кнопки
//*******************************************************************

//--------Обработка времени------------------------------------------
//-------------------------------------------------------------------
typedef struct {                        //структура для хранения времени
               unsigned char hour;      //часы
               unsigned char min;       //минуты
               unsigned char sec;       //секунды
               }Time;
               
Time realTime;                          //реальное время
Time alarm[3];                          //будильники
unsigned char activateAlarm[3];         //активность будильников

#define ON  1
#define OFF 0
unsigned char clockOnOff=OFF;           //флаг работы идикации часов
#define clock(n) clockOnOff=n           //включение или выключение индикации часов

//--------вывод на дисплей времени-----------------------------------
void displayTime(unsigned char h,unsigned char m,unsigned char s,   //отображаемые значения
                 unsigned char x,unsigned char y,                   //начальная позиция для вывода 
                 unsigned char blPos);                              //0 - не мигать, >3 - мигает все, 1,2,3 - мигают отдельные позиции

//--------установка значения времени---------------------------------
unsigned char setTime(unsigned char *h,unsigned char *m,unsigned char *s,//устанавливаемые значения                                               
                      Dir enc,Button key,unsigned char tick);			 //состояние энкодер, состояние кнопки, время между вызовами функции
//*******************************************************************

//--------обработка меню---------------------------------------------
//-------------------------------------------------------------------
#define TICK 10			//периодичность обработки кода фоновой программы

enum {
    expectInput,		//ожидание входа в меню (меню не работает)
    enterMenu,			//вход в меню
    processing,			//обработка меню
    execution,			//выполнение подменю
    activate,			//активировать будильник
    save,				//вывод сообщения о сохранении настройки
    exitMenu,			//завершаем работу меню
}menuState=expectInput; //состояние обработки меню

#define maxMenu 4                   //количество пунктов меню
const char menuNames[maxMenu][17]={ //названия пунктов меню
    "Настроить время ",
    "Первый будильник",
    "Второй будильник",
    "Третий будильник"
};    
//*******************************************************************

//========ГЛАВНАЯ ФУНКЦИЯ ПРОЕКТА====================================
//===================================================================
int main(void){
//--------локальные переменные---------------------------------------
Button tempKey;           //хранение значения нажатой кнопки
Dir tempEncoder;          //хранение состояния энкодера
unsigned char number=0;   //номер пункта меню
unsigned int counter=0;   //для задержек времени
   
//--------отключение делителя частоты--------------------------------
CLKPR=1<<CLKPCE;
CLKPR=0;

//--------настройка портов ввода/вывода------------------------------
                        //выход таймера T0 для генератора звука
					    //подтяжка входов для энкодера
					    //подтяжка входа для кнопки

//--------настройка Т0-----------------------------------------------
TCCR0A=(0<<COM0A1)|(0<<COM0A0)|(0<<WGM01)|(0<<WGM00);       //режим работы №=2 CTC, инверсия выхода OC0A при совпадении таймера

//--------настройка Т1-----------------------------------------------
TCCR1A=(0<<COM1A1)|(0<<COM1A0)|(0<<WGM11)|(0<<WGM10);       //режим №4 СТС
TCCR1B=(0<<WGM13)|(1<<WGM12)|(1<<CS12)|(0<<CS11)|(1<<CS10); //к=64
OCR1AH=15625>>8;                                            //прерывание раз в секунду
OCR1AL=15625;
TIMSK1=(1<<OCIE1A);                                         //разрешение прерывания по совпадению

//--------настройка Т2-----------------------------------------------
TCCR2A=(0<<WGM21)|(0<<WGM20);                       //режим СТС 
TCCR2B=(0<<WGM22)|(0<<CS22)|(0<<CS21)|(0<<CS20);    //к=1024
OCR2A=0x9C;                                         //интервал 10мс

//--------настройка внешнего прерывания------------------------------
EICRA=(0<<ISC11)|(0<<ISC10)|(0<<ISC01)|(0<<ISC00);  //прерывание по срезу импульса
EIMSK=(0<<INT1)|(0<<INT0);                          //включаем внешнее прерывание INT0
EIFR=(0<<INTF1)|(1<<INTF0);

SREG|=1<<7;                                         //общее разрешение прерываний 

//--------инициализация дисплея--------------------------------------
					//инициализация дисплея                
					//включение дисплея

//--------приветствие------------------------------------------------
soundON();                                 //включить генерацию мелодии
MT16S2H_putstr((char*)"2018");             //вывод текстовой строки на русском языке 
									       //переход в начало второй строки
MT16S2H_putstr((char*)" WSR ");            //вывод текстовой строки на английском
_delay_ms(10000);                          //задержка отображения приветствия 
                                           //очистка дисплея
clock(ON);                                 //включить индикацию времени

//--------фоновая программа------------------------------------------
for(;;_delay_ms(TICK)){               //фоновая программа обрабатывается с периодичностью в 10мс
    //--------опрос ввода--------------------------------------------
    tempKey=getKey(TICK);             //опрашиваем кнопку
    tempEncoder=encoderStatus();      //опрашиваем энкодер
       
    //--------обработка меню:----------------------------------------
    switch(menuState){                //определяем обрабатываемый пункт меню
    //--------ожидание входа в меню (меню не работает)---------------
    case expectInput:               
        if((tempKey!=noPress)||       //если нажали кнопку или
           (tempEncoder!=notR))       //вращался энкодер, то
            menuState=enterMenu;      //входим в меню
    break;                                                    
    
    //--------вход в меню:-------------------------------------------    
    case :                 
        clock(OFF);									//выключаем индикацию времени
        MT16S2H_clr();								//очищаем экран
        MT16S2H_putstr((char*)"    Меню 1:     ");	//вывод заголовка меню
        menuState=processing;						//переходим к обработке меню                  
    break;                  
    
    //--------обработка меню:----------------------------------------    
    case :                
        if(tempEncoder==right){     //вращение меню вверх
            if(++number>=maxMenu)   //увеличиваем позицию меню
                number=0;
        }
        if(tempEncoder==left){      //вращение меню вниз
            //if()                  //уменьшить позицию меню
            //   ;                            
        }
        
        if(tempKey==longPress){     //если было длинное нажатие кнопки, то 
            menuState=exitMenu;     //завершаем работу меню  
        }
        
        if(tempKey==shortPress){    //если было короткое нажатие кнопки, то 
            menuState=execution;    //приступаем к выполнению подменю  
        }
        
        MT16S2H_gotoxy(9,0);                         //переходим в позицию номера строки
        MT16S2H_getchar(number+'1');                 //выводим номер меню
        MT16S2H_gotoxy(0,1);                         //переходим в начало второй строки
        //MT16S2H_putstr((char*)&menuNames[number][0]);//выводим название меню
    break;                                                 
    
    //--------выполнение подменю:------------------------------------
    case :      
        MT16S2H_gotoxy(0,0);                         //переходим в начало первой строки
        //MT16S2H_putstr((char*)&menuNames[number][0]);//выводим название меню
        
        //--------ввод времени---------------------------------------
        if(number==0){                        
            if(setTime(&realTime.hour,&realTime.min,&realTime.sec,tempEncoder,tempKey,TICK))
                menuState=save;                   //выводим сообщение о сохранении результата
        }
        //--------насройка будильников-------------------------------                                                            
        else{                                                                                
            if(setTime(&alarm[number-1].hour,&alarm[number-1].min,&alarm[number-1].sec,tempEncoder,tempKey,TICK))
                menuState=activate;               //выводим сообщение о сохранении результата
        }
    break;
    
    //--------активировать будильник---------------------------------
    case :              
        if(tempKey==){               //если было длинное нажатие, то сохраняем будильник
            menuState=save;                   //выводим сообщение о сохранении результата                    
        }    
        else                                  //иначе продолжаем настраивать будильник
        if((tempKey!=)||               //если было зафиксированна любое нажатие, то
           (tempEncoder!=notR)){
            activateAlarm[number-1]=!activateAlarm[number-1];//переключаем будильник
        }
        
        MT16S2H_gotoxy(0,0);                  //переходим в начало первой строки
        //MT16S2H_putstr((char*)"    Будильник   ");   //вывод надписи
        MT16S2H_gotoxy(0,1);                  //переходим в начало второй строки 
        if(activateAlarm[number-1]==ON)       //если будильник включен
            MT16S2H_putstr((char*)"    включен!!!  ");   //выводим надпись
        //else                                             
            //MT16S2H_putstr((char*)"     выключен   ");   //выводим надпись
    break;
    
    //--------вывод сообщения о сохранении настройки-----------------
    case :
        if((counter+=TICK)>300){             //если прошло 3 секунды, то         
            menuState=enterMenu;              //возвращаемся в меню
            counter=0;
        }
    break;           
            
    //--------завершаем работу меню:---------------------------------    
    case :                  
        number=0;                   //сбрасываем номер меню
                                    //очищаем экран
        clock(OFF);                 //включаем часы
        menuState=;                 //выходим из меню
    break;
    }   
}//for(;;)
return 0;
}//END MAIN
//===================================================================

//========прерывание Т1 по совпадению в канале А=====================
//===================================================================
ISR(TIMER1_COMPA_vect){
//--------локальные переменные---------------------------------------
static unsigned char updatingText=0;            //номер строки выводимого екста    
unsigned char txt[1][17]={"   WorldSkills  ",   //текст для вывода во второй строке
                          "     Russia     ",
                          "   Electronics  "};
unsigned char i;                                //счетчик для работы циклов

//--------подсчет времени и проверка будильников---------------------
if(++realTime.sec>=60){             //счет секунд
                                    //счет минут
                                    //счет часов

    //проверка будильников один раз в минуту
    for(i=0;i<3;++i){                           //проверяем все три будильника
        if((activateAlarm[i]==ON)&&             //если будтльник совпал, то 
           (alarm[i].hour==realTime.hour)&&
           (alarm[i].min==realTime.min)){
            soundON();                          //включаем воспроизведение мелодии
        }            
    }
}

if(clockOnOff==OFF)return;                      //выключение индикации

//--------вывод времени на дисплей-----------------------------------
displayTime(realTime.hour,realTime.min,realTime.sec,0,0,0);

MT16S2H_getchar(' ');

//--------индикация включенных будильников---------------------------
if(activateAlarm[0]==ON);                         //если будильник включен, то рисуем колокольчик
else                    MT16S2H_getchar(' ');                    

if(activateAlarm[1]==ON);                         //если будильник включен, то рисуем колокольчик
else                    MT16S2H_getchar(' ');                    

if(activateAlarm[2]==ON)                    ;    //если будильник включен, то рисуем колокольчик
else                    MT16S2H_getchar(' ');                    

//--------вывод надписи в нижней строке экрана-----------------------
MT16S2H_gotoxy(0,1);      //переходим во вторую строку
if(++updatingText>=6)     //определяем, какое слово выводить
    updatingText=6;
    
MT16S2H_putstr((char*)&txt[updatingText/2][3]);//вывод текстовой строки      
}//void tim1_compa(void)
//===================================================================

//========прерывание Т2 по совпадению в канале А=====================
//===================================================================
ISR(TIMER2_COMPA_vect){
//--------локальные переменные---------------------------------------
static unsigned char notPosition=0; //номер воспроизводимой ноты в мелодии
static unsigned char iteration=0;   //для измерения длительности воспроизведения ноты
static unsigned char leng=0;        //длительность воспроизводимой ноты

//--------генерация мелодии------------------------------------------
if(iteration++==0){                           //настройка новой ноты
    TCNT0=0;                                  //предварительно производим сброс счетчика в 0
    OCR0A=rateNotes[melody[0][notPosition]];  //загрузка частоты воспроизводимой ноты
    TCCR0B=(0<<CS02)|(0<<CS01)|(0<<CS00);     //предделитель k=64 (включение звукового сигнала)                                                          
        
    if(melody[1][notPosition]==4)leng=20;     //загрузка длительности воспроизведение ноты
    else if(melody[1][notPosition]==2)leng=40;
         
}else if(iteration>leng){                     //формирование короткой паузы между нотами
    iteration=0;                              //сбрасываем счетчик длительности ноты
    TCCR0B=0;                                 //выключаем генерацию звукового сигнала
    
    if(++notPosition>=melodyLenght){          //выбираем очередную ноту из масива мелодии
        notPosition=0;                        //сброс номера воспроизводимой ноты
        TIMSK2=0;                             //выключить воспроизведение мелодии
        TCCR0B=0;                             //выключение звукового сигнала
        TCNT0=0;
    }
}
}//void tim1_compa(void)
//===================================================================

//========обработчик внешнего прерывания INT0========================
//===================================================================
ISR(INT0_vect){
//--------опрос направления вращения энкодера------------------------
if(PIND&1<<3)direction=left;     //если второй контакт энкодера разомкнут, значит вал крутят против часовой стрелки
else         direction=right;    //иначе, значит, что вал крутят по часовой стрелки
}//void ext_int0(void)
//===================================================================

//--------обработка кнопки-------------------------------------------
//-------------------------------------------------------------------
Button getKey(unsigned char tick){
//--------локальные переменные---------------------------------------
static unsigned int counter=0; //счетчик нажатия кнопки
Button press=noPress;          //результат нажатия кнопки

//--------измеряем время нажатия кнопки------------------------------
if((PIND&1<<4)==0){            //если кнопка нажата, то
    if((counter+tick)<counter) //увеличиваем счетчик и следим, 
        counter=3000;          //чтоб он не переполнился
    else counter+=tick;        //иначе увеличиваем время нажатия кнопки
}
else{ 
    if(counter>=longTime){     //если кнопка не нажата, то проверяем время ее нажатия 
        press=longPress;                                                    
    }
    else if(counter>=shortTime){     
        press=shortPress;                                                    
    }
    
    counter=0;                 //очищаем счетчик для следующего измерения
}

return press;                  //возвращаем длительность нажатия кнопки
}//unsigned char get_key(void)
//*******************************************************************

//--------вывод на дисплей времени-----------------------------------
//-------------------------------------------------------------------
void displayTime(unsigned char h,unsigned char m,unsigned char s,
                 unsigned char x,unsigned char y,unsigned char blPos){
MT16S2H_gotoxy(x,y);            //установка позиции вывода времени
if(blPos==1){                   //выключаем указанную позицию        
    MT16S2H_getchar(' ');
    MT16S2H_getchar(' ');
}
else{    
    MT16S2H_getchar(h/10+'0');  //вывод десятков часов
    MT16S2H_getchar(h%10+'0');  //вывод единиц часов  
}
MT16S2H_getchar(':');           //вывод разделительного знака
if(blPos==2){                   //выключаем указанную позицию        
    MT16S2H_getchar(' ');
    MT16S2H_getchar(' ');
}
else{    
    MT16S2H_getchar();  //вывод десятков минут
    MT16S2H_getchar();  //вывод единиц минут
}
MT16S2H_getchar(':');           //вывод разделительного знака
if(blPos==3){                   //выключаем указанную позицию        
    MT16S2H_getchar(' ');
    MT16S2H_getchar(' ');
}
else{    
    MT16S2H_getchar();  //вывод десятков секунд
    MT16S2H_getchar();  //вывод единиц секунд
}
}//displayTime(h,m,s,blPos=0)                
//*******************************************************************

//--------установка значения времени---------------------------------
//-------------------------------------------------------------------
unsigned char setTime(unsigned char *h,unsigned char *m,unsigned char *s,
                      Dir enc,Button key, unsigned char tick){
//--------локальные переменные---------------------------------------
static unsigned char pos=1;            //позиция ввода числа
static unsigned int counter=0;         //счетчик для измерения времени

*s=0;                                  //сбрасываем секунды

if((counter+=tick)>1000)counter=0;     //считаем время

if(key==shortPress){                   //если произошло короткое нажатие, то
    if(++pos>2)pos=1;                  //переходим к вводу следующей позиции
    counter=500;                       //чтобы позиция сразу начала мигать с выключенного состояния 
}

if(enc==right){                        //прибавляем время
    counter=0;                         //чтоб позиция не мигала во время ввода
    if(pos==1){                        //устанавливаем часы
        if(++*h>=24)*h=0;        
    }
    else{             
        if(++*m>=60)*m=0;
    }
}

if(enc==left){                         //прибавляем время
    counter=0;                         //чтоб позиция не мигала во время ввода
    if(pos==1){                        //устанавливаем часы
        if(--*h>=24)*h=23;        
    }
    else{             
        if(--*m>=60)*m=59;
    }
}

if(key==longPress){
    pos=1;          //подготавливаемся к следующему запуску
    counter=0;
    return 1;       //если было длинное нажатие кнопки, то досрочно выходим
}

//--------вывод установленных значений-------------------------------
MT16S2H_gotoxy(0,1);
MT16S2H_getchar(' ');
MT16S2H_getchar(' ');
MT16S2H_getchar(' ');
MT16S2H_getchar(' ');
if(counter<500)                   //мигать раз в секунду
    displayTime(*h,*m,*s,4,1,0);  //выводим все символы
else
    displayTime(*h,*m,*s,4,1,pos);//выключаем вводимую позицию 
MT16S2H_getchar(' ');
MT16S2H_getchar(' ');
MT16S2H_getchar(' ');
MT16S2H_getchar(' ');
MT16S2H_getchar(' ');      

return 0;       //функция не закончила свою работу           
}//void setTime(*h,*m,*s,x,y)
//*******************************************************************

//--------инициализация дисплея--------------------------------------
//-------------------------------------------------------------------
void MT16S2H_init(void){
//--------настройка портво для управления дисплеем-------------------
A0_DDR|=1<<A0; 
E_DDR|=1<<E;  
DB4_DDRD|=1<<DB4;   
DB5_DDRD|=1<<DB5;
DB6_DDRD|=1<<DB6;
DB7_DDRD|=1<<DB7;

//--------инициализация дисплея для работы по 4х битной шине---------
clr_A0();          //передача команд  
_delay_ms(100);    //ждем пока дисплей оживет

//Установить разрядность интерфейса
MT16S2H_set_DB(0b00000011);
set_E();           _delay_us(1);
clr_E();           _delay_ms(1);

set_E();           _delay_us(1);
clr_E();           _delay_ms(1);

set_E();           _delay_us(1);
clr_E();           _delay_ms(1);

MT16S2H_set_DB(0b00000010);
set_E();           _delay_us(1);
clr_E();           _delay_ms(1);

//Установка параметров
MT16S2H_set_DB(0b00000010);
set_E();           _delay_us(1);
clr_E();           _delay_us(1);

MT16S2H_set_DB(0b00001010);
set_E();           _delay_us(1);
clr_E();           _delay_ms(1);

//Выключение дисплея
MT16S2H_set_DB(0b00000000);
set_E();           _delay_us(1);
clr_E();           _delay_us(1);

MT16S2H_set_DB(0b00001000);
set_E();           _delay_us(1);
clr_E();           _delay_ms(1);

//Очистка дисплея
MT16S2H_set_DB(0b00000000);
set_E();           _delay_us(1);
clr_E();           _delay_us(1);

MT16S2H_set_DB(0b00000001);
set_E();           _delay_us(1);
clr_E();           _delay_ms(1);

//Установка режима ввода
MT16S2H_set_DB(0b00000000);
set_E();           _delay_us(1);
clr_E();           _delay_us(1);

MT16S2H_set_DB(0b00000110);
set_E();           _delay_us(1);
clr_E();           _delay_ms(1);
}//void MT16S2H_init(void)
//*******************************************************************

//--------инициализация дисплея--------------------------------------
//-------------------------------------------------------------------
void MT16S2H_write(unsigned char data,unsigned char a){
if(a==1)set_A0();else clr_A0();

MT16S2H_set_DB(data>>4);
set_E();_delay_us(1);
clr_E();_delay_us(1);

MT16S2H_set_DB(data);
set_E();_delay_us(1);
clr_E();_delay_us(40);
}//void MT16S2H_write(unsigned char data,unsigned char a)
//*******************************************************************

//--------установка шины данных--------------------------------------
void MT16S2H_set_DB(unsigned char data){
if(data&(1<<0))DB4_PORT|=1<<DB4;else DB4_PORT&=~(1<<DB4);
if(data&(1<<1))DB5_PORT|=1<<DB5;else DB5_PORT&=~(1<<DB5);
if(data&(1<<2))DB6_PORT|=1<<DB6;else DB6_PORT&=~(1<<DB6);
if(data&(1<<3))DB7_PORT|=1<<DB7;else DB7_PORT&=~(1<<DB7);
}//void MT16S2H_set_DB(unsigned char data)                
//*******************************************************************

//--------перевод курсора--------------------------------------------
//-------------------------------------------------------------------
void MT16S2H_gotoxy(unsigned char x,unsigned char y){
if(y>0)x+=0x40; //переход во вторую строку 

MT16S2H_write(x|(1<<7),COMMAND);
}//void MT16S2H_gotoxy(unsigned char x,unsigned char y)   
//*******************************************************************

//--------вывод текстовой строки-------------------------------------
//-------------------------------------------------------------------
void MT16S2H_putstr(char *str){
for(;*str!='\0';++str)
    MT16S2H_getchar(*str);
}//void MT16S2H_putstr(unsigned char *str)                
//*******************************************************************


//--------очистка дисплея--------------------------------------------
//-------------------------------------------------------------------
void MT16S2H_clr(void){
MT16S2H_write(1,COMMAND);
_delay_ms(2);
}//void MT16S2H_clr(void)
//*******************************************************************                                                                
